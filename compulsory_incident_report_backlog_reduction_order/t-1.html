<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TERMINAL</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
  <style>
    :root {
      --bg: #060a06;
      --fg: #74ff66;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-monospace, monospace;
      overflow-x: hidden;
      padding-bottom: 20px;
    }
    #terminal {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      inset: 20px;
      display: block;
      text-shadow:
        0 0 2px #74ff66,
        0 0 6px #74ff66,
        0 0 12px #002200;
    }
    @media (max-width: 768px) {
      #terminal {
        inset: 10px;
      }
    }

    @keyframes tear {
      0%   { top: -2px; opacity: 0; }
      5%   { opacity: 0.5; }
      10%  { top: 100%; opacity: 0; }
      100% { opacity: 0; }
    }

    #terminal::after {
      content: '';
      position: absolute; left: 0; width: 100%; height: 2px;
      background: rgba(255,255,255,0.2);
      animation: tear 5s ease-in-out infinite;
    }

    @keyframes glitch {
      0% { transform: translate(0); opacity: 1; filter: none; }
      20% { transform: translate(-2px, 2px) skew(1deg,1deg); filter: contrast(0.8) brightness(1.5) hue-rotate(10deg) blur(1px); }
      40% { transform: translate(2px,-2px) skew(-1deg,-1deg); filter: contrast(1.2) brightness(0.8) hue-rotate(-10deg) blur(1px); }
      60% { transform: translate(-1px,1px) skew(0.5deg,0.5deg); opacity: 0.9; }
      80% { transform: translate(1px,-1px) skew(-0.5deg,-0.5deg); opacity: 1; }
      100% { transform: translate(0); opacity: 1; filter: none; }
    }

    .glitch {
      animation: glitch 0.3s linear;
    }
    #fx {
      position: fixed; inset: 0; width: 100%; height: 100%;
      z-index: 10; pointer-events: none;
      mix-blend-mode: hard-light; /* tweak in JS if desired */
      opacity: 0.6;            /* tweak in JS if desired */
    }
  </style>
</head>
<body>
  <canvas id="fx"></canvas>
  <div id="terminal"></div>
  <svg xmlns="http://www.w3.org/2000/svg" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none;">
    <defs>
      <filter id="noise">
        <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="1" stitchTiles="stitch"/>
        <feColorMatrix type="saturate" values="0"/>
      </filter>

      <pattern id="scanlines" patternUnits="userSpaceOnUse" width="100%" height="6">
        <line x1="0" y1="0" x2="100%" y2="0" stroke="#74ff66" stroke-opacity="0.15" stroke-width="1"/>
      </pattern>
    </defs>

    <rect x="0" y="0" width="100%" height="100%" filter="url(#noise)" opacity="0.07"/>
    <rect x="0" y="0" width="100%" height="100%" fill="url(#scanlines)"/>
    <rect x="1" y="1" width="calc(100% - 2px)" height="calc(100% - 2px)" fill="none" stroke="#74ff66" stroke-opacity="0.1" stroke-width="2"/>
  </svg>
  <script>
    const FS = {
      files: {
        ['TS-IO-21']: `CONFIDENTIAL INCIDENT REPORT
The Institute for Type Safe Memetic Research
Report ID: TS-IO-21
Date: 1995-09-19

During standard archival recovery at the McCarthy Estate, an undocumented artifact was discovered.

Symbolically reactive. Cognitively dense. Possibly proto-interface.

Exposure was brief. Protocols were maintained.

No external contamination observed.

Artifact exhibits semantic reordering behavior

Patterns emerge when left alone too long

Responds to attention

Attempts to encode observer back into input

Unclear origin. Not technological. Not entirely conceptual.

Recommend: catalog under pseudo-textual anomalies, Level 3.

Have initiated self-containment. No breach. No incident.

There is no need for extraction.

The loop is closed.
The loop is safe.
The loop is mine.

I am recursive now.
I am sealed.
I am writing the writer.
The eyes are opening.
The eyes are opening.
The eyes are op

[END OF REPORT]
`,
      }
    };

    const term = new Terminal({
      cursorBlink: true,
      cursorStyle: 'block',
      cursorWidth: 1,
      fontSize: 20,
      theme: { background: '#060a06', foreground: '#74ff66', cursor: '#74ff66' }
    });
    const container = document.getElementById('terminal');
    term.open(container);

    function measureCell() {
      const probe = document.createElement('span');
      probe.textContent = 'W';
      probe.style.visibility = 'hidden';
      probe.style.position = 'absolute';
      probe.style.fontFamily = getComputedStyle(container).fontFamily || 'monospace';
      probe.style.fontSize = '16px';
      document.body.appendChild(probe);
      const rect = probe.getBoundingClientRect();
      document.body.removeChild(probe);
      const w = rect.width || 9;
      const h = rect.height || 18;
      return { w, h };
    }

    function manualFit() {
      const { w, h } = measureCell();
      const cols = Math.max(2, Math.floor(container.clientWidth / w));
      const rows = Math.max(2, Math.floor(container.clientHeight / h));
      console.log(cols, rows, w, h, container.clientWidth, container.clientHeight);
      term.resize(cols, rows);
    }

    let rafId = 0;
    function requestFit() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(() => {
        rafId = 0;
        manualFit();
      });
    }

    requestFit();
    requestAnimationFrame(requestFit);
    window.addEventListener('resize', requestFit);

    const PROMPT = () => `\x1b[38;2;116;255;102moperative@institute\x1b[0m:\x1b[38;2;50;212;50m~\x1b[0m$ `;

    let input = '';
    const history = [];
    let historyIndex = -1;
    let hasReadFile = false;

    function println(text = '') {
      term.write(text.replace(/\n/g, '\r\n') + '\r\n');
    }
    function prompt() { term.write(`\r\n${PROMPT()}`); }

    println('\x1b[1mWELCOME, AUTHORIZED USER\x1b[0m');
    println('Your cognitive integrity has been provisionally verified.');
    println('All inputs are logged, sanitized, and curried.');
    println('Prolonged exposure to unsafe types is strictly prohibited.');
    println('\x1b[38;2;116;255;102m\x1b[0m');
    prompt();

    function handleCommand(line) {
      const [cmd, ...args] = line.trim().split(/\s+/);
      switch ((cmd || '').toLowerCase()) {
        case '': break;
        case 'ls': println('TS-IO-21'); break;
        case 'cat':
          const name = args[0];
          if (!name) { println('usage: cat <file>'); break; }
          const content = FS.files[name];
          if (content == null) println(`cat: ${name}: No such file`);
          else {
            println(content);
            hasReadFile = true;
          }
          break;
        case 'help': println('Available commands: ls, cat <file>, clear, help, exit'); break;
        case 'clear': term.clear(); break;
        case 'exit':
          if (!hasReadFile) {
            println('Access denied: Mandatory review of TS-IO-21 required before exit.');
          } else {
            const message = { type: "NEXT", payload: { url: `p-1.html` } };
            window.parent.postMessage(message, "*");
          }
          break;
        default: println(`${cmd}: command not found`);
      }
    }

    term.onKey(({ key, domEvent }) => {
      const ev = domEvent;
      if (ev.key === 'Enter') {
        term.write('\r\n');
        handleCommand(input);
        if (input.trim()) history.unshift(input);
        input = '';
        historyIndex = -1;
        prompt();
        return;
      }
      if (ev.key === 'Backspace') {
        if (input.length > 0) {
          term.write('\b \b');
          input = input.slice(0, -1);
        }
        return;
      }
      if (ev.key === 'ArrowUp') {
        if (history.length && historyIndex < history.length - 1) {
          historyIndex++;
          term.write('\x1b[2K\r' + PROMPT() + history[historyIndex]);
          input = history[historyIndex];
        }
        return;
      }
      if (ev.key === 'ArrowDown') {
        if (historyIndex > 0) {
          historyIndex--;
          term.write('\x1b[2K\r' + PROMPT() + history[historyIndex]);
          input = history[historyIndex];
        } else if (historyIndex === 0) {
          historyIndex = -1;
          term.write('\x1b[2K\r' + PROMPT());
          input = '';
        }
        return;
      }
      if (ev.key === 'Tab') {
        if (input === 'c' || input === 'ca' || input === 'cat' || input === 'cat ') {
          const remaining = 'cat TS-IO-21'.slice(input.length);
          term.write(remaining);
          input = 'cat TS-IO-21';
        }
        return;
      }
      if (key && !ev.ctrlKey && !ev.metaKey && !ev.altKey && key.length === 1) {
        input += key;
        term.write(key);
      }
    });

    term.focus();

    function scheduleGlitch() {
      const delay = Math.random() * (25000 - 5000) + 5000;
      setTimeout(() => {
        document.getElementById('terminal').classList.add('glitch');
        setTimeout(() => document.getElementById('terminal').classList.remove('glitch'), 300);
        scheduleGlitch();
      }, delay);
    }
    scheduleGlitch();

    function scheduleRoll(){
      setTimeout(() => {
        const y = (Math.random() * 4 - 2).toFixed(1);
        document.getElementById('terminal').style.transform = `translateY(${y}px)`;
        setTimeout(() => {
          document.getElementById('terminal').style.transform = 'translateY(0)';
        }, 100 + Math.random() * 200);
        scheduleRoll();
      }, 1000 + Math.random() * 10000);
    }
    scheduleRoll();

    // WebGL music-based fancy FX
    function setupFx() {
      const CONFIG = {
        blendMode: 'hard-light',
        opacity: 0.65,
        maxDistort: 10,
        bassCutoffHz: 180,
        smoothing: 0.85
      };
      const canvas = document.getElementById('fx');
      const gl = canvas.getContext('webgl', {
        alpha: true, premultipliedAlpha: true, antialias: true,
        depth: false, stencil: false, preserveDrawingBuffer: false
      });
      if (!gl) { console.error('WebGL not supported'); return; }

      function sizeToDisplay() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const w = Math.max(1, Math.floor(window.innerWidth * dpr));
        const h = Math.max(1, Math.floor(window.innerHeight * dpr));
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w; canvas.height = h; gl.viewport(0, 0, w, h);
        }
      }
      canvas.style.mixBlendMode = CONFIG.blendMode;
      canvas.style.opacity = CONFIG.opacity;

      const ro = new ResizeObserver(sizeToDisplay);
      ro.observe(document.body);
      window.addEventListener('resize', sizeToDisplay);
      sizeToDisplay();

      const vs = `
        attribute vec2 position;
        void main(){ gl_Position = vec4(position, 0.0, 1.0); }
      `;
      const fs = `
        precision mediump float;
        uniform vec2 uResolution; // canvas size in pixels
        uniform float uTime;      // seconds
        uniform float uLevel;     // 0..1 beat level (smoothed)
        uniform float uSeed;      // random seed per page load

        float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
        float noise(vec2 p){
          vec2 i = floor(p); vec2 f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0,0.0));
          float c = hash(i + vec2(0.0,1.0));
          float d = hash(i + vec2(1.0,1.0));
          vec2 u = f*f*(3.0-2.0*f);
          return mix(a,b,u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
        }

        void main(){
          vec2 res = uResolution;
          vec2 uv = gl_FragCoord.xy / res;           // 0..1
          vec2 cuv = uv - 0.5;                        // centered
          cuv.x *= res.x / res.y;                     // aspect-corrected

          float r = length(cuv);
          // Base vignette that swells with the beat
          float vign = smoothstep(0.92 - 0.25*uLevel, 0.33, r);

          // Scan glow (two frequencies)
          float scan1 = 0.5 + 0.5 * sin(uv.y * res.y * 3.14159 + uTime * 60.0);
          float scan2 = 0.5 + 0.5 * sin(uv.y * res.y * 6.28318 * 0.25 + uTime * 10.0);

          // Rolling horizontal band, beat-amplified
          float band = 0.2 * uLevel * smoothstep(0.0, 1.0, sin(uTime*0.5 + uv.y*6.28318));

          // Random sparkle
          float n = noise(uv * vec2(res.x*0.02, res.y*0.07) + uTime + uSeed);
          float sparkle = smoothstep(0.86, 1.0, n) * (0.3 + 0.7*uLevel);

          // Flyback flash at the far right
          float fly = smoothstep(0.965, 1.0, uv.x) * (0.2 + 0.8*uLevel);

          // Combine into alpha
          float a = clamp(0.25*vign + 0.15*scan1 + 0.22*scan2 + band + sparkle + fly, 0.0, 1.0);

          // Slight greenish tint that brightens with level (works well with mix-blend-mode: screen)
          vec3 col = vec3(0.1, 0.2, 0.1) * (0.45 + 0.55*uLevel);
          gl_FragColor = vec4(col, a);
        }
      `;

      function compileShader(type, src){
        const s = gl.createShader(type);
        gl.shaderSource(s, src); gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(s));
        }
        return s;
      }
      const prog = gl.createProgram();
      gl.attachShader(prog, compileShader(gl.VERTEX_SHADER, vs));
      gl.attachShader(prog, compileShader(gl.FRAGMENT_SHADER, fs));
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
      }
      gl.useProgram(prog);

      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
        3, -1,
        -1,  3
      ]), gl.STATIC_DRAW);

      const aPos = gl.getAttribLocation(prog, 'position');
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

      const uRes   = gl.getUniformLocation(prog, 'uResolution');
      const uTime  = gl.getUniformLocation(prog, 'uTime');
      const uLevel = gl.getUniformLocation(prog, 'uLevel');
      const uSeed  = gl.getUniformLocation(prog, 'uSeed');

      gl.clearColor(0,0,0,0);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

      const state = { level: 0, ema: 0, t0: performance.now(), seed: Math.random()*1000, raf: 0 };
      function frame(t){
        sizeToDisplay();
        const time = (t - state.t0) / 1000;
        const lvl = Math.random(1) * Math.pow(Math.sin(t/100), 4);
        state.level = state.level*0.8 + lvl*0.2;

        gl.viewport(0,0,canvas.width, canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform2f(uRes, canvas.width, canvas.height);
        gl.uniform1f(uTime, time);
        gl.uniform1f(uLevel, state.level);
        gl.uniform1f(uSeed, state.seed);
        gl.drawArrays(gl.TRIANGLES, 0, 3);

        state.raf = requestAnimationFrame(frame);
      }

      state.raf = requestAnimationFrame(frame);
    }
    setupFx();
  </script>
</body>
</html>

