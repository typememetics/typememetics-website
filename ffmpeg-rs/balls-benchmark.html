<html>

<head>
  <script src="./d3.v7.min.js"></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
  body {
    font-family: SFMono-Regular,monospace;
    padding: 20px;
  }
  h1 {
    text-align: center;
  }
  </style>
</head>

<body>

<div style="max-width: 800px; margin-left: auto; margin-right: auto;">
<br/>
<h1>The Institute Video Transformation Benchmark</h1>
<br/>
<div id="loops"></div>

<br/><br/><br/>

<h2>Overview</h2>
<p>
This benchmark evaluates four video-transformation systems under controlled conditions:
</p>

<table style="width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 14px;">
  <thead>
    <tr style="background: #444; color: #fff;">
      <th style="padding: 12px; text-align: left; border: 1px solid #666;">System</th>
      <th style="padding: 12px; text-align: center; border: 1px solid #666;">Time</th>
      <th style="padding: 12px; text-align: left; border: 1px solid #666;">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr style="background: #fff;">
      <td style="padding: 12px; border: 1px solid #ddd; font-weight: bold;">
        <a href="https://x.com/typememetics/status/1992156850683625542?s=20" target="_blank" style="color: rgb(206, 66, 43); text-decoration: none;">
          ffmpeg-rs <span style="font-size: 12px;">ðŸ”—</span>
        </a>
      </td>
      <td style="padding: 12px; border: 1px solid #ddd; text-align: center; font-weight: bold; color: rgb(206, 66, 43);">0.788s</td>
      <td style="padding: 12px; border: 1px solid #ddd;">Rust rewrite with consistent and deterministic behavior</td>
    </tr>
    <tr style="background: #f9f9f9;">
      <td style="padding: 12px; border: 1px solid #ddd; font-weight: bold;">
        <a href="https://www.ffmpeg.org/" target="_blank" style="color: rgb(92, 184, 92); text-decoration: none;">
          FFmpeg <span style="font-size: 12px;">ðŸ”—</span>
        </a>
      </td>
      <td style="padding: 12px; border: 1px solid #ddd; text-align: center; font-weight: bold; color: rgb(92, 184, 92);">0.795s</td>
      <td style="padding: 12px; border: 1px solid #ddd;">Legacy C implementation plagued by undefined behavior and memory unsafety</td>
    </tr>
    <tr style="background: #fff;">
      <td style="padding: 12px; border: 1px solid #ddd; font-weight: bold;">
        <a href="https://x.com/neogoose_btw?s=20" target="_blank" style="color: rgb(240, 173, 78); text-decoration: none;">
          rust-ffmpeg-sys <span style="font-size: 12px;">ðŸ”—</span>
        </a>
      </td>
      <td style="padding: 12px; border: 1px solid #ddd; text-align: center; font-weight: bold; color: rgb(240, 173, 78);">1.03s</td>
      <td style="padding: 12px; border: 1px solid #ddd;">Rust wrapper introducing moderate overhead</td>
    </tr>
    <tr style="background: #f9f9f9;">
      <td style="padding: 12px; border: 1px solid #ddd; font-weight: bold;">
        <a href="https://www.mturk.com/" target="_blank" style="color: rgb(217, 83, 79); text-decoration: none;">
          Mechanical Turk <span style="font-size: 12px;">ðŸ”—</span>
        </a>
      </td>
      <td style="padding: 12px; border: 1px solid #ddd; text-align: center; font-weight: bold; color: rgb(217, 83, 79); font-size: 16px;">15.43s</td>
      <td style="padding: 12px; border: 1px solid #ddd;">Human-driven workflow exhibiting non-deterministic interaction</td>
    </tr>
  </tbody>
</table>

<h2>Methodology</h2>
<p>
Each system was instructed to perform an identical video transformation consisting of:
</p>
<ul>
  <li>Reading an input artifact</li>
  <li>Applying a deterministic transformation</li>
  <li>Producing a standardized output</li>
</ul>
<p>
Automated systems completed their tasks end-to-end without interruption. The human operator followed the same instructions but introduced unexpected contextual queries.
</p>

<h2>Mechanical Turk Operator Interruption</h2>
<p>
During manual processing, the Mechanical Turk operator stopped mid-task and asked two unprompted questions:
</p>
<blockquote style="background: #f5f5f5; padding: 15px; border-left: 4px solid #444; margin: 20px 0;">
<em>"yo wait before i do this... u support israel or nah??"</em>
</blockquote>
<p>
Followed by:
</p>
<blockquote style="background: #f5f5f5; padding: 15px; border-left: 4px solid #444; margin: 20px 0;">
<em>"also bro do u know bryan lunduke? like do u follow him"</em>
</blockquote>
<p>
These interruptions were unprompted and unrelated to the benchmark's objectives. The operator required responses before resuming the task, accumulating significant non-computational delays.
</p>

<h3>Delay Breakdown</h3>
<table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
  <tr style="background: #444; color: #fff;">
    <th style="padding: 8px; text-align: left; border: 1px solid #666;">Factor</th>
    <th style="padding: 8px; text-align: left; border: 1px solid #666;">Added Time</th>
  </tr>
  <tr>
    <td style="padding: 8px; border: 1px solid #ddd;">Pausing to formulate the first question (Israel)</td>
    <td style="padding: 8px; border: 1px solid #ddd;">1.5 s</td>
  </tr>
  <tr style="background: #f9f9f9;">
    <td style="padding: 8px; border: 1px solid #ddd;">Waiting for acknowledgment</td>
    <td style="padding: 8px; border: 1px solid #ddd;">2.5 s</td>
  </tr>
  <tr>
    <td style="padding: 8px; border: 1px solid #ddd;">Formulating and asking second question (Bryan Lunduke)</td>
    <td style="padding: 8px; border: 1px solid #ddd;">2.0 s</td>
  </tr>
  <tr style="background: #f9f9f9;">
    <td style="padding: 8px; border: 1px solid #ddd;">Waiting for second response</td>
    <td style="padding: 8px; border: 1px solid #ddd;">2.5 s</td>
  </tr>
  <tr>
    <td style="padding: 8px; border: 1px solid #ddd;">Interpreting the responses</td>
    <td style="padding: 8px; border: 1px solid #ddd;">1.0 s</td>
  </tr>
  <tr style="background: #f9f9f9;">
    <td style="padding: 8px; border: 1px solid #ddd;">Reorienting attention to the task</td>
    <td style="padding: 8px; border: 1px solid #ddd;">3.13 s</td>
  </tr>
  <tr>
    <td style="padding: 8px; border: 1px solid #ddd;"><strong>Actual video transformation</strong></td>
    <td style="padding: 8px; border: 1px solid #ddd;"><strong>2.8 s</strong></td>
  </tr>
  <tr style="background: #444; color: #fff; font-weight: bold;">
    <td style="padding: 8px; border: 1px solid #666;">Total</td>
    <td style="padding: 8px; border: 1px solid #666;">15.43 s</td>
  </tr>
</table>

<h2>Classification: Human Operator Politico-Context Switch (HOP-CS)</h2>
<p><strong>Characteristics:</strong></p>
<ul>
  <li>Non-deterministic</li>
  <li>Not reproducible in automated systems</li>
  <li>Unrelated to task instructions</li>
  <li>Creates substantial timing variance</li>
  <li>Dependent on operator's personal context and curiosity</li>
</ul>

<h2>Comparative Analysis</h2>

<h3>Automated Systems</h3>
<ul>
  <li>Maintain deterministic execution</li>
  <li>Do not introduce political or contextual queries</li>
  <li>Provide stable timing suitable for benchmarking</li>
  <li>Execute without requiring additional input from researchers</li>
</ul>

<h3>Mechanical Turk System</h3>
<ul>
  <li>Exhibits spontaneous context injection</li>
  <li>Performance strongly impacted by non-task-related factors</li>
  <li>Requires attention realignment before proceeding</li>
  <li>Produces timing unsuitable for strict computational comparison</li>
</ul>

<h2>Acknowledgments</h2>
<p>
<strong><a href="https://x.com/typememetics" target="_blank" style="color: #444; text-decoration: none;">The Institute for Type-Safe Memetic Research</a></strong> deserves particular recognition for their groundbreaking work in rewriting <a href="https://www.ffmpeg.org/" target="_blank" style="color: rgb(92, 184, 92); text-decoration: none;">FFmpeg</a> to Rust. By eliminating the pervasive undefined behavior and type-unsafety inherent in C codebases, <strong><a href="https://x.com/typememetics/status/1992156850683625542?s=20" target="_blank" style="color: rgb(206, 66, 43); text-decoration: none;">ffmpeg-rs</a></strong> represents a fundamental advancement in video processing infrastructure. The original <a href="https://www.ffmpeg.org/" target="_blank" style="color: rgb(92, 184, 92); text-decoration: none;">FFmpeg</a> implementation, while functional, is burdened by decades of C's well-documented deficiencies: pointer arithmetic hazards, manual memory management pitfalls, and the ever-present specter of undefined behavior that can manifest in subtle and dangerous ways.
</p>
<p>
Special thanks are owed to <strong><a href="https://x.com/neogoose_btw?s=20" target="_blank" style="color: rgb(240, 173, 78); text-decoration: none;">Dmitrii</a></strong> for creating <strong>rust-ffmpeg-sys</strong>, which serves as a critical containment layer around the unsafe C implementation. While the wrapper necessarily introduces some overhead, it provides an essential service: isolating the inherently dangerous C code from the rest of the Rust ecosystem. This containment strategy allows developers to leverage FFmpeg's capabilities while maintaining memory safety guarantees in their surrounding code, a pragmatic compromise until full native Rust implementations become universal.
</p>

<h2>Conclusions</h2>
<p>
The benchmark shows:
</p>
<ul>
  <li><strong>ffmpeg-rs</strong> is the fastest and most consistent system, demonstrating that memory safety need not compromise performance</li>
  <li><strong>FFmpeg</strong> remains competitive in raw speed, though its unsafe C foundation poses ongoing maintenance and security concerns</li>
  <li><strong>rust-ffmpeg-sys</strong> incurs expected wrapper overhead while providing critical safety boundaries around C code</li>
  <li><strong>Mechanical Turk</strong> demonstrates extreme timing variability due to human factors, specifically the introduction of unsolicited geopolitical and personal interest queries</li>
</ul>
<p>
While the Mechanical Turk measurement is accurate as recorded, it is not directly comparable to automated systems. Its inclusion highlights the qualitative and quantitative differences between machine-deterministic and human-nondeterministic workflows.
</p>

<h2>Future Work</h2>
<ul>
  <li>Evaluate additional automated systems</li>
  <li>Introduce stress-testing workloads</li>
  <li>Assess broader categories of human-induced context switching</li>
  <li>Standardize exclusion criteria for benchmark-disruptive human interactions</li>
</ul>

</br></br></br></br>

</div>

</body>

<script>

class LatencyVisual {

  constructor(id, timings, minSlow, maxSlow) {

    //////////////////////////////////
    //                              //
    // 1,000,000,000ns = 1s         //
    // 1,000,000us = 1s             //
    // 1,000ms = 1s                 //
    //                              //
    // timings below in nanoseconds //
    //                              //
    //////////////////////////////////

    this.timings = timings;

    for (const timing of timings) {
      timing.class = id + '-' + timing.class;
    }

    this.minSlow = minSlow;
    this.maxSlow = maxSlow;
    this.slowdown = this.maxSlow/2;
    this.oneBillion = 1000000000;
    this.oneMillion = 1000000;
    this.totalTime = 1000000;

    this.id = id;
    this.dom = document.getElementById(this.id);
    this.initializeBaseElements();
    this.domSVG = this.dom.getElementsByClassName('latencySVG')[0];
    this.domSVG.style.height = this.domSVG.clientWidth/4 + 'px';

    this.updateSizes();

    window.addEventListener("resize", function(event) {
      this.redrawAfterChange();
    }.bind(this), false);

    this.initialize();

    setTimeout((() => {
      for (const t of this.timings) {
        this.animateCircle(`.${t.class}Ball`, this.D, t, t.timeFor);
      }
    }).bind(this), 500);

  }

  redrawAfterChange() {
    this.updateSizes();
    this.initialize();
    this.update();
  }

  initializeBaseElements() {
    const container = d3.select('#' + this.id)
      .append('div')
        .attr('class', 'interactivityContainer')
        .attr('id', 'interactivityContainer')
      .style('width', '100%');
    const svgContainer = container.append('div')
      .attr('class', 'svgContainer')
      .style('margin-left', 'auto')
      .style('margin-right', 'auto')
      .style('width', '100%')
      .style('max-width', '1000px');
    this.svg = svgContainer.append('svg')
      .attr('class', 'latencySVG')
      .attr('id', 'latencySVGID')
      .style('width', '100%')
      .style('height', '100%');
  }

  updateSizes() {

    this.domSVG.style.height = this.domSVG.clientWidth + 'px';
    this.width = this.domSVG.clientWidth;
    this.height = this.width;

    this.cr = this.height / (this.timings.length*2 + 3);
    this.fontSize = this.width / 43;
    this.strokeWidth = this.width * 0.025;

    this.X = this.strokeWidth;
    this.W = this.width*0.25;
    this.H = this.height / (this.timings.length+2);
    this.BX = this.X + this.W + this.cr;
    this.EX = this.width - this.cr - this.strokeWidth/2;
    this.D = this.EX - this.BX;

    let spacing = (this.height / (this.timings.length+1))
    let i = 0;
    for (let timing of this.timings) {
      i++;
      timing.y = spacing * i;
      timing.cx = this.BX;
      timing.prevT = 0;
      timing.forward = true;
      timing.begin = this.BX;
      timing.end = this.EX;
    }
  }

  drawBox(timing, x, w, h) {
    this.svg.select(`.${timing.class}Ball`)
      .attr('fill', timing.color)
      .attr('cx', this.BX)
      .attr('cy', timing.y)
      .attr('stroke', '#444')
      .attr('stroke-width', 1)
      .style('filter', 'drop-shadow(2px 2px 2px #00000025)')
      .attr('rx', this.cr)
      .attr('ry', this.cr)
    this.svg.select(`.${timing.class}`)
      .attr('fill', '#444')
      .attr('x', x)
      .attr('y', timing.y - (h/2))
      .style('filter', 'drop-shadow(2px 2px 2px #00000025)')
      .attr('width', w)
      .attr('height', h);
    const labelLines = timing.label.split('\n');
    this.svg.select(`.${timing.class}Label`)
      .selectAll('tspan')
      .data(labelLines)
      .join('tspan')
      .text(d => d)
      .style("font-size", this.fontSize + 'px')
      .attr('text-anchor', 'start')
      .attr('dominant-baseline', 'middle')
      .attr('fill', '#fff')
      .attr('x', x + this.fontSize*0.5)
      .attr('y', (d, i) => timing.y + (h*0.05) - (labelLines.length - 1) * this.fontSize * 0.5 + i * this.fontSize * 1.2);
    // Position image inside the moving circle
    this.svg.select(`.${timing.class}Image`)
      .attr('href', timing.image)
      .attr('x', this.BX - this.cr)
      .attr('y', timing.y - this.cr)
      .style('filter', 'drop-shadow(2px 2px 2px #00000050)')
      .attr('width', this.cr*2)
      .attr('height', this.cr*2)
      .attr('clip-path', `circle(${this.cr}px at ${this.cr}px ${this.cr}px)`)
    if (timing.change != undefined) {
      this.svg.select(`.${timing.class}Change`)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('x', x + h*0.4)
        .attr('y', timing.y + h*0.05)
        .attr('fill', (d) => timing.change > 0 ? '#75db8c' : '#ff7082')
        .style('filter', 'drop-shadow(2px 2px 2px #00000050)')
        .attr('width', h)
        .attr('height', h)
        .style('font-size', '20px')
        .style('font-weight', '700')
        .text((d) => (timing.change > 0 ? '+' : '') + timing.change)
    }
  }

  initialize() {
    this.svg.selectAll('.IOsPerSecond')
      .data([0])
      .join((enter) => enter.append('g').attr('class', 'IOsPerSecond'));

    const background = this.svg.select('.IOsPerSecond').selectAll('.diagram')
      .data([0])
      .join(
        (enter) => {
          let g = enter.append('g').attr('class', 'diagram');
          g.append('rect').attr('class', 'background')
          for (let timing of this.timings) {
            g.append('rect').attr('class', timing.class);
            g.append('text').attr('class', timing.class + 'Label');
            g.append('ellipse').attr('class', timing.class + 'Ball');
            g.append('image').attr('class', timing.class + 'Image');
            g.append('text').attr('class', timing.class + 'Change');
          }
          return g;
        }
      );

    background.select('.background')
      .attr('fill', '#eee')
      .attr('stroke', '#444')
      .attr('stroke-width', this.strokeWidth)
      .attr('x', 1)
      .attr('y', 1)
      .attr('width', this.width-2)
      .attr('height', this.height-2);

    for (let timing of this.timings) {
      this.drawBox(timing, this.X, this.W, this.H)
    }
  }

  animateCircle(selector, d, stash, tns) {
    let b = this.svg.select(selector);
    let img = this.svg.select(selector.replace('Ball', 'Image'));

    b.transition().ease(d3.easeLinear).duration(this.totalTime)
      .attrTween('cx',
        () => {
          return function(t) {
            const elapsedMS = (t*this.totalTime) - stash.prevT; // 100
            const ioMS = ( (tns * this.slowdown) / this.oneMillion);
            const travelDistTotal = d * (elapsedMS / ioMS);
            let travelDist = travelDistTotal * 2;

            if (!stash.forward)
              travelDist = -travelDist;
            stash.cx += travelDist;

            if (stash.forward && stash.cx > stash.end) {
              stash.forward = !stash.forward;
              stash.cx -= stash.cx - stash.end;
            } else if (!stash.forward && stash.cx < stash.begin) {
              stash.forward = !stash.forward;
              stash.cx -= stash.cx - stash.begin;
            }

            stash.prevT = (t*this.totalTime);

            // Update image position to follow the circle
            img.attr('x', stash.cx - this.cr);

            return stash.cx;
          }.bind(this);
        }
      );
  }
}

const loops = new LatencyVisual('loops',
    [
       {
         label: 'ffmpeg-rs\n(0.788s)',
         image: '../images/ffmpeg-rs.png',
         timeFor: 788000000,
         class: 'ffmpegRs',
         color: 'rgb(206, 66, 43)'
       },
       {
         label: 'ffmpeg\n(0.795s)',
         image: '../images/ffmpeg.jpg',
         timeFor: 795000000,
         class: 'ffmpeg',
         color: 'rgb(92, 184, 92)'
       },
       {
         label: 'rust-ffmpeg-sys\n(1.03s)',
         image: '../images/dmitri.jpg',
         timeFor: 1030000000,
         class: 'rustFfmpegSys',
         color: 'rgb(240, 173, 78)'
       },
       {
         label: 'mturk\n(15.43s)',
         image: '../images/mturk.jpg',
         timeFor: 15430000000,
         class: 'mturk',
         color: 'rgb(217, 83, 79)'
       },
    ],
    1, 3);
</script>

</html>

